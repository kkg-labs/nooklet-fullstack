### **Story Title: Implement Time-Based Nooklet Chunking and Reconstruction in Editor**

**Status:** Approved

**User Story:**
As a Creator,
I want my continuous writing to be intelligently chunked into separate nooklets based on time gaps,
so that my timeline accurately reflects distinct thoughts or sessions, and I can easily review and edit them.

**Story Context:**
*   **Integrates with:** Home page markdown editor (Quick Capture), Nooklet data model, auto-save mechanisms, timeline display.
*   **Technology:** React, AdonisJS backend, PostgreSQL (JSONB for content).
*   **Pattern:** Continuous capture, time-based event triggering, granular data updates.

**Acceptance Criteria:**
1.  When a user pauses typing in the markdown editor for longer than a defined time gap (e.g., 2 minutes for dev/test, 45 minutes for production), the current content is saved as a distinct new nooklet.
2.  Subsequent typing after such a time gap initiates a new nooklet, appearing chronologically after the previous one.
3.  On initial load of the timeline, only nooklets from today and yesterday are fetched and displayed.
4.  Older nooklets are lazily loaded as the user scrolls down the timeline (e.g., via infinite scroll or a "Load More" mechanism).
5.  When retrieving nooklets for a specific day (or loaded range), the system concatenates the content of all nooklets within that range into a single view within the markdown editor, ordered chronologically by their creation/update timestamps.
6.  The editor maintains the correct chronological order of text blocks when displaying concatenated content, using invisible markers to delineate original nooklet boundaries for internal processing.
7.  The UI provides a subtle visual indicator to highlight the text block where the user's cursor is currently positioned.
8.  When a user edits an existing text block, the frontend detects the specific `Nooklet` entry being modified and sends *only that modified block's content* to the backend for an upsert operation.
9.  When a user deletes content that corresponds to an existing text block, the frontend detects this and sends a request to delete that specific `Nooklet` entry.
10. New tests verify the time-based chunking, granular saving/updating/deleting, retrieval, lazy loading, and reconstruction logic, including the UI indicator.

**Tasks / Subtasks:**
- [ ] Implement frontend logic to detect typing pauses and trigger save events for *new* `Nooklet` entries based on the defined time gap (2 min / 45 min).
- [ ] Implement frontend logic to detect edits within *existing* `Nooklet` entries and send only the modified block's content (identified by ID/timestamp) to the backend for upsert.
- [ ] Implement frontend logic to detect deletion of *existing* `Nooklet` entries and send delete requests for those IDs.
- [ ] Implement backend endpoint to receive individual `Nooklet` content upserts (by ID) and deletions.
- [ ] Develop backend API to support fetching nooklets by date range (e.g., today, yesterday) and paginated/infinite scroll for older entries.
- [ ] Develop backend logic to retrieve nooklets for a given range and concatenate their content chronologically for display. This includes inserting invisible markers between nooklet contents.
- [ ] Implement frontend logic for initial load of today's and yesterday's nooklets.
- [ ] Implement frontend infinite scroll or "Load More" functionality for lazy loading older nooklets.
- [ ] Implement frontend logic to display the concatenated markdown content in the editor, ensuring invisible markers are used for internal processing but stripped for user display.
- [ ] Implement frontend UI to display a subtle visual indicator for the active text block based on cursor position.
- [ ] Create comprehensive unit and integration tests for time-based chunking, granular saving/updating/deleting, retrieval, lazy loading, and reconstruction, including the UI indicator.
- [ ] Update `architecture.md` with details on the time-based chunking and granular saving/loading strategy.

**Dev Notes:**
*   **Time Gap Detection:** Frontend will detect typing pauses. Reference `architecture.md` for "5-minute typing pause detection" as a general concept. For this story, the time gap is **2 minutes for development/testing and 45 minutes for production.**
*   **Saving/Chunking (Frontend to Backend):** The frontend is responsible for identifying new text blocks (based on time gaps) and modified/deleted existing text blocks. It sends only the affected block's content (or ID for deletion) to the backend.
*   **Backend Handling:** The backend receives individual `Nooklet` content updates (upserts) or delete requests, identified by `Nooklet` ID. It will not perform complex diffing of the entire timeline.
*   **Retrieval/Reconstruction:** Backend API will support date-range and paginated queries. Frontend will manage initial load and lazy loading. The concatenation logic will apply to the *currently loaded* set of nooklets. Frontend displays this single string. Crucially, the backend will insert invisible markers (e.g., special HTML comments or unique delimiters) between concatenated nooklet contents. The frontend will use these markers for internal processing (e.g., identifying blocks for granular updates) but will strip them before rendering to the user.
*   **Frontend UI:** The frontend will use the invisible markers to determine the boundaries of the current text block and apply a visual highlight based on the user's cursor position.

**Change Log:**
| Date | Version | Description | Author |
|---|---|---|---|
| 2025-09-09 | 1.0 | Initial story creation | John (PM) |

**Dev Agent Record:**
**Agent Model Used:**
**Debug Log References:**
**Completion Notes List:**
**File List:**

**QA Results:**

**Definition of Done:**
- [ ] Functional requirements are met and tested.
- [ ] All existing and new tests pass.